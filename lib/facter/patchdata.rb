#
# Note that a chunk does not imply a nesting ...
# See https://docs.puppet.com/facter/3.6/fact_overview.html#writing-structured-facts
# See https://docs.puppet.com/facter/2.0/fact_overview.html#writing-structured-facts
#
Facter.add(:patchdata, :type => :aggregate) do

  overridefile = "/tmp/patching/override.txt"
  # Cached data to avoid exec within custom facts, generated by the Puppet
  # prerun_command 
  pkginfofile = "/tmp/patching/cache/cache.rpm-qaf"
  kerneldatafile = "/tmp/patching/cache/cache.kernel"
  yumrepolistfile = "/tmp/patching/cache/cache.yum.repolist"
  yumrepolistcode = "/tmp/patching/cache/cache.yum.repolist.code"
  yumupdatefile = "/tmp/patching/cache/cache.yum.cu"
  yumupdatecode = "/tmp/patching/cache/cache.yum.cu.code"
  yumsecupdatefile = "/tmp/patching/cache/cache.yum.scu"
  yumsecupdatecode = "/tmp/patching/cache/cache.yum.scu.code"
  yumcvefile = "/tmp/patching/cache/cache.yum.listsec"
  yumcvecode = "/tmp/patching/cache/cache.yum.listsec.code"
  compliancefile = "/tmp/patching/compliance.txt"

  # Only run on Linux
  confine :kernel => "Linux"

  chunk(:versioning) do
    data = {}
    data["version"] = {:version => "Patch data V1"}
    data
  end

  # Collect data for later processing
  # If we do need to run external commands, only run them once.
  # BIOS is the exception - see dmidecode calls below
  runningkern = Facter::Core::Execution.exec('/bin/uname -a')
  anyblockers = false # Anything blocking patching?
  osfacts = Facter.value(:os)
  # Global variables for final compliance calc
  supported_os_releases = [ '6.7', '6.9', '7.3', '7.4' ]
  compliance_secupdates = 0 # Count of security updates
  compliance_updates = 0 # Count of normal updates
  time_to_patch = 365 # Default setting - one year to apply patches

  # All of the following are based on cache files generated by the Puppet
  # prerun_command
  if File.file?(kerneldatafile)
    kerneldata = File.open(kerneldatafile, "r").read # .strip
  end
  if File.file?(pkginfofile)
    allrpm = File.open(pkginfofile, "r").read # .strip
  end
  if File.file?(yumrepolistfile)
    repodata = File.open(yumrepolistfile, "r").read # .strip
  end
  if File.file?(yumrepolistcode)
    repodataexit = File.open(yumrepolistcode, "r").read.strip.to_i
  end
  if File.file?(yumupdatefile)
    updates = File.open(yumupdatefile, "r").read # .strip
  end
  if File.file?(yumupdatecode)
    updatesexit = File.open(yumupdatecode, "r").read.strip.to_i
  end
  if File.file?(yumsecupdatefile)
    secupdates = File.open(yumsecupdatefile, "r").read # .strip
  end
  if File.file?(yumsecupdatecode)
    secupdatesexit = File.open(yumsecupdatecode, "r").read.strip.to_i
  end
  if File.file?(yumcvefile)
    cvedata = File.open(yumcvefile, "r").read # .strip
  end
  if File.file?(yumcvecode)
    cvedatacode = File.open(yumcvecode, "r").read.strip.to_i
  end
  if File.file?(compliancefile)
    compliancedata = File.open(compliancefile, "r").read
  end

  # Begin generating hash components
  chunk(:syserrsrpm) do
    data = {}
    if (! kerneldata)
      data['errorcheck'] = {:systemerrorrpm => "RPM test returned a non-zero exit code"}
    end
    data
  end
  chunk(:syserrsyum) do
    data = {}
    if (repodataexit != 0)
      data['errorcheck'] = {:systemerroryum => "YUM test returned a non-zero exit code"}
    end
    data
  end
  chunk(:syserrsrepo) do
    data = {}
    if (repodata)
      if (repodata.include? "Errno")
        data['errorcheck'] = {:systemerrorrepo => "Repolist command is showing errors"}
      end
      data
    end
  end

  # Collect all enabled repos and the number of packages in place
  chunk(:yumrepos) do
    data = {}
    newdata = {}
    if (repodata)
      repodata.each_line do |line|
        # Data format is reponame,desc,numpkgs
        matchdata = line.match(/^(\S+)\s+(.+)\s+([\d,]+)$/)
        if (matchdata)
          data[matchdata[1]] = {:repodesc => matchdata[2].strip, :repopkgs => matchdata[3]}
        end
      end
      newdata['repos'] = data
      newdata
    end
  end

  # Information on kernel - some info duplicated between here and the patchfact chunk below
  chunk(:kernelfact) do
    data = {}
    arraydata = {}
    lastkern = ''
    if (kerneldata)
      kerneldata.each_line do |line|
        matchdata = line.match(/^\d+\s+kernel-(\S+)$/)
        if (matchdata)
          arraydata[matchdata[1]] = matchdata[1]
          lastkern = matchdata[1]
        end
      end
      activekern = runningkern.match(/Linux\s+\S+\s+(\S+)\s+/)
      arraydata['active'] = activekern[1]

      if (osfacts['release']['major'].to_i < 5)
        data['patchingblockedby'] = {:runningkerneltooold => true}
        anyblockers = true
      else
        if (osfacts['release']['major'].to_i == 5)
          lastkern.sub!(/.el5.\S+/,'.el5')
          arraydata['kernelv5'] = lastkern # DEBUG
        end

        if (lastkern == activekern[1])
          arraydata['kernelmismatch'] = false
          data['patchingblockedby'] = {:runningkerneltooold => false, :runningkernelmismatch => false}
        else
          arraydata['kernelmismatch'] = true
          data['patchingblockedby'] = {:runningkerneltooold => false, :runningkernelmismatch => true}
          anyblockers = true
        end
      end
      data['kernelpkgs'] = arraydata
      data
    end
  end

  chunk(:overrides) do
    # Have we picked up overrides?
    if File.file?(overridefile)
      data = {}
      data['patchingblockedby'] = {:overrideblocker => false}
      hostname = Facter.value(:hostname)
      File.open(overridefile, "r").each_line do |line|
        # File format is hostname,reason
        filedata = line.split(/,/)
        host, overridereason = filedata.map{|d,e| d.strip }
        if (host == hostname)
          data['patchingblockedby'] = {:overrideblocker => true}
          data['patchingoverride'] = overridereason
          anyblockers = true
        end
      end
      data
    end
  end

  # BIOS data
  chunk(:biosfact) do
    data = {}
    virtual = Facter.value(:virtual)
    if (virtual == "physical")
      data['patchfact'] = {:biosvendor => Facter::Core::Execution.exec("/usr/sbin/dmidecode -s 'bios-vendor'"),
       :biosrevision => Facter::Core::Execution.exec("/usr/sbin/dmidecode -t 0 | grep 'BIOS Revision:' | awk -F: '{print $2}'"),
       :serialnumber => Facter::Core::Execution.exec("/usr/sbin/dmidecode -s 'system-serial-number'"),
       :skunumber => Facter::Core::Execution.exec("/usr/sbin/dmidecode -t 1 | grep 'SKU Number:' | awk -F: '{print $2}'"),
       :family => Facter::Core::Execution.exec("/usr/sbin/dmidecode -t 1 | grep 'Family:' | awk -F: '{print $2}'")}
    end
    data
  end

  # Display CVE data
  # This includes all RHSA as well as bugfixes, so not completely CVE. But, this is
  # what we are most interested in. Arrange as a hash of priority with array of ids.
  chunk(:cvedata) do
    data = {}
    arraydata = {}
    if (cvedata)
      cvedata.each_line do |line|
        # RH-id priority pkg
        matchdata = line.match(/^(\S+)\s+(\S+)\s+(.*)/)
        if (matchdata)
          if (!arraydata[matchdata[2]])
            arraydata[matchdata[2]] = Array.new
          end
          arraydata[matchdata[2]].push matchdata[1]

          # Set up our patching grace time in days based on severity of RH advisory
          time_to_patch_tmp = time_to_patch
          if (matchdata[2].include? "Critical")
          #if (matchdata[2] =~ /Critical/)
            time_to_patch_tmp = 21
          elsif (matchdata[2].include? "Important")
            time_to_patch_tmp = 42
          elsif ((matchdata[2].include? "Moderate") or (matchdata[2].include? "bugfix"))
            time_to_patch_tmp = 56
          elsif (matchdata[2].include? "enhancement")
            time_to_patch_tmp = 120
          end
          # Update timer if we have less time due to a more critical patch
          if (time_to_patch_tmp < time_to_patch)
            time_to_patch = time_to_patch_tmp
          end
        end
      end
      data['updateinfo'] = arraydata
      data
    end
  end

  # Display all RPMs to be upgraded - work on security updates first, to keep pkgdata clean
  chunk(:updatedata) do
    data = {}
    arraydata = {}
    pkgdata = {}
    if (secupdates)
      if (secupdatesexit == 100)
        secupdates.each_line do |line|
          matchdata = line.match(/^(\S+)\s+(\S+)\s+\S+.*$/)
          if (matchdata)
            pkgdata[matchdata[1]] = matchdata[2]
          end
        end
        arraydata['secupdatelist'] = pkgdata
      end
      compliance_secupdates = pkgdata.count # Collect for later compliance calculations
      arraydata['secnumupdates'] = compliance_secupdates
    end
    pkgdata = {}  # Clear hash for processing new list of packages
    if (updates)
      if (updatesexit == 100)
        updates.each_line do |line|
          matchdata = line.match(/^(\S+)\s+(\S+)\s+\S+.*$/)
          if (matchdata)
            pkgdata[matchdata[1]] = matchdata[2]
          end
        end
        arraydata['updatelist'] = pkgdata
      end
      compliance_updates = pkgdata.count # Collect for later compliance calculations
      arraydata['numupdates'] = compliance_updates
    end
    data['updates'] = arraydata
    data
  end

  chunk(:compliance) do
    if (cvedata)
      data = {}
      last_normal_compliance_date = 0
      last_security_compliance_date = 0
      currentdate = Time.now.to_i
      oneday = (24 * 60 * 60) # How long is one day in seconds
      expirydays = (time_to_patch * oneday) # How long until we must patch in seconds
      data['patching_grace_days_from_last_compliance'] = time_to_patch
      data['patching_current_time'] = currentdate
  
      # Do we have a dispensation
      if (Facter.value(:dispensations).keys.any?)
        dispensation = false
        data['patchingblockedby'] = {:dispensation => false}
      else
        dispensation = true
        data['patchingblockedby'] = {:dispensation => true}
        anyblockers = true
      end

      # Are we an EOL version of the OS? See the list of supported versions top of this script.
      supported_os = false
      supported_os_releases.each do |rel|
        if (osfacts['release']['full'] == rel)
          supported_os = true
        end
      end

      # We record information on the last time we were compliant - analyse
      if (compliancedata)
        compliancedata.each_line do |line|
          if (lastnormal = line.match(/^LastCompliant: (\d+)$/))
            last_normal_compliance_date = lastnormal[1].to_i
          end
        end
      else
        last_normal_compliance_date = nil
      end

      # Fact based on normal updates
      if (compliance_secupdates == 0) # no patches - set compliant as of now
        data['patching_last_compliant'] = 0
      elsif (last_normal_compliance_date != 0) # we have patches, so are tracking last compliance date
        data['patching_last_compliant'] = last_normal_compliance_date
      elsif (!last_normal_compliance_date and (compliance_secupdates != 0)) # we have patches and have no previous date - set to now
        data['patching_last_compliant'] = currentdate
        #data['patching_last_compliant'] = currentdate - oneday # previously we set to yesterday, but this caused some confusion around windows
      else
        data['patching_last_compliant'] = currentdate # default is to set to today
      end
      # Calculate expiry
      if (data['patching_last_compliant'] == 0)
        secondsuntilexpiry = expirydays
      else
        secondsuntilexpiry = (expirydays - (currentdate - data['patching_last_compliant']))
      end
      data['days_until_patch_non_compliant'] = secondsuntilexpiry / oneday

      # write out to compliance file  - do it in Puppet

      # Logic to determine compliance level, in order of importance.
      if (data['days_until_patch_non_compliant'] < 0)
        data['compliance'] = 'Non-Compliant'
      elsif ((compliance_secupdates == 0) and supported_os)
        data['compliance'] = 'Compliant'
      elsif (dispensation)
        data['compliance'] = 'Managed Non-Compliant'
      elsif (compliance_secupdates > 0)
        data['compliance'] = 'Patching-Required'
      elsif (!supported_os)
        data['compliance'] = 'EOL'
      else
        data['compliance'] = 'Compliant'
      end
      data
    end
  end

  # Summarise blocking data
  chunk(:patchingblockedsummary) do
    data = {}
    data['patchingisblocked'] = anyblockers
    data
  end
end